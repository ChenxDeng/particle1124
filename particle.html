<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 手势控制粒子系统</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        /* 摄像头预览窗口 */
        #camera-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transform: scaleX(-1); /* 镜像 */
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 全屏按钮 */
        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            z-index: 10;
        }

        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* 加载提示 */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            pointer-events: none;
            text-align: center;
        }

        /* 状态指示 */
        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://unpkg.com/@mediapipe/tasks-vision@0.10.0/vision_bundle.js"
            }
        }
    </script>
</head>
<body>

    <div id="loader">正在初始化 AI 视觉引擎...<br><small>请允许摄像头权限</small></div>
    <div id="status">等待手势识别...</div>

    <div id="camera-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <button id="fullscreen-btn">⛶ 全屏模式</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

        // --- 配置 ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.15;
        
        // --- 全局变量 ---
        let scene, camera, renderer, controls, particles, geometry, material;
        let handLandmarker = undefined;
        let webcamRunning = false;
        let lastVideoTime = -1;
        let handScaleFactor = 1.0; // 手势控制的缩放因子
        
        // 目标形状数据
        const shapes = {
            sphere: [],
            heart: [],
            saturn: [],
            flower: [],
            buddha: [] // 这里的佛像用抽象几何体代替
        };

        // 当前配置
        const config = {
            shape: 'heart',
            color: '#ff0055',
            speed: 0.05, // 变形速度
            baseScale: 1.0
        };

        // --- 初始化 ---
        async function init() {
            // 1. Three.js 场景设置
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // 2. 生成粒子数据
            generateShapeData();

            // 3. 创建粒子系统
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            
            // 初始位置设为随机
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 100;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // 保存每个粒子的当前目标位置
            geometry.userData.target = new Float32Array(PARTICLE_COUNT * 3);
            updateTargetShape(config.shape);

            // 简单的圆形纹理生成
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            material = new THREE.PointsMaterial({
                color: config.color,
                size: PARTICLE_SIZE,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                alphaTest: 0.5,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 4. UI 面板
            setupGUI();

            // 5. 启动 MediaPipe 和 摄像头
            await setupMediaPipe();
            
            // 6. 事件监听
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            document.getElementById('loader').style.display = 'none';

            // 7. 开始动画循环
            animate();
        }

        // --- 形状生成算法 ---
        function generateShapeData() {
            // 辅助函数：随机点在球面上
            const getSpherePoint = (r) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            };

            // 1. 球体 (Sphere - 默认/烟花初始态)
            const sData = [];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                sData.push(...getSpherePoint(10));
            }
            shapes.sphere = sData;

            // 2. 爱心 (Heart)
            const hData = [];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                // 3D Heart parametric equations
                let t = Math.random() * Math.PI * 2;
                let u = Math.random() * Math.PI; // simple distribution
                // 更有体积感的爱心方程
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random()-0.5) * 4; // Thickness
                
                // 缩放一下
                x *= 0.5; y *= 0.5; z *= 2;
                hData.push(x, y, z);
            }
            shapes.heart = hData;

            // 3. 土星 (Saturn)
            const satData = [];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                if (i < PARTICLE_COUNT * 0.7) {
                    // Planet body
                    satData.push(...getSpherePoint(6));
                } else {
                    // Rings
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 8 + Math.random() * 6;
                    satData.push(Math.cos(angle) * dist, (Math.random()-0.5)*0.5, Math.sin(angle) * dist);
                }
            }
            shapes.saturn = satData;

            // 4. 花朵 (Flower - 3D Rose)
            const fData = [];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                // 玫瑰线变体
                const r = 10 * Math.sin(3 * theta) * Math.sin(4 * phi);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                fData.push(x, y, z);
            }
            shapes.flower = fData;

            // 5. 抽象佛像/冥想态 (Geometric Stack)
            // 由于加载模型复杂，我们用几何堆叠模拟打坐姿态
            const bData = [];
            for(let i=0; i<PARTICLE_COUNT; i++) {
                let x,y,z;
                const r = Math.random();
                if(r < 0.3) { // Head
                   [x,y,z] = getSpherePoint(2.5);
                   y += 6;
                } else if (r < 0.7) { // Body
                    const theta = Math.random() * Math.PI * 2;
                    const height = (Math.random() - 0.5) * 8;
                    const radius = 4 - Math.abs(height)*0.3;
                    x = Math.cos(theta) * radius;
                    y = height;
                    z = Math.sin(theta) * radius;
                } else { // Base/Legs
                    const theta = Math.random() * Math.PI * 2;
                    const rad = 5 + Math.random() * 5;
                    x = Math.cos(theta) * rad;
                    y = -5 + (Math.random()*2);
                    z = Math.sin(theta) * rad;
                }
                bData.push(x,y,z);
            }
            shapes.buddha = bData;
        }

        function updateTargetShape(shapeKey) {
            const targetArr = geometry.userData.target;
            const sourceArr = shapes[shapeKey];
            
            if (!sourceArr) return;

            for(let i=0; i< sourceArr.length; i++) {
                targetArr[i] = sourceArr[i];
            }
        }

        // --- MediaPipe 手势识别设置 ---
        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });

            const video = document.getElementById('webcam');
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', () => {
                        webcamRunning = true;
                    });
                });
            }
        }

        // --- 实时手势检测逻辑 ---
        async function detectHands() {
            const video = document.getElementById('webcam');
            if (!handLandmarker || !webcamRunning || video.paused || video.currentTime === lastVideoTime) return;

            lastVideoTime = video.currentTime;
            const results = handLandmarker.detectForVideo(video, performance.now());

            const statusEl = document.getElementById('status');

            if (results.landmarks && results.landmarks.length > 0) {
                // 检测到手
                statusEl.innerText = "已连接：控制粒子缩放";
                statusEl.style.color = "#00ffaa";

                // 获取第一只手
                const landmarks = results.landmarks[0];
                
                // 计算大拇指(4)和食指(8)指尖的距离
                const thumb = landmarks[4];
                const index = landmarks[8];
                const dist = Math.sqrt(
                    Math.pow(thumb.x - index.x, 2) + 
                    Math.pow(thumb.y - index.y, 2)
                );

                // 映射距离到缩放因子
                // 距离通常在 0.02 (闭合) 到 0.2 (张开) 之间
                // 目标 Scale: 0.5 (收缩) 到 2.5 (扩散)
                const normalizedDist = Math.min(Math.max((dist - 0.05) / 0.15, 0), 1);
                const targetScale = 0.5 + (normalizedDist * 2.0);

                // 平滑过渡
                handScaleFactor += (targetScale - handScaleFactor) * 0.1;

            } else {
                statusEl.innerText = "未检测到手势 - 请在摄像头前展示手掌";
                statusEl.style.color = "#ffffff";
                // 无手势时缓慢恢复默认大小
                handScaleFactor += (1.0 - handScaleFactor) * 0.05;
            }
        }

        // --- GUI 设置 ---
        function setupGUI() {
            const gui = new GUI({ title: '控制面板' });
            
            gui.add(config, 'shape', {
                '爱心 Heart': 'heart',
                '土星 Saturn': 'saturn',
                '花朵 Flower': 'flower',
                '佛像/禅 Buddha': 'buddha',
                '球体/烟花 Sphere': 'sphere'
            }).name('模型选择').onChange(val => updateTargetShape(val));

            gui.addColor(config, 'color').name('粒子颜色').onChange(val => {
                material.color.set(val);
            });

            gui.add(config, 'speed', 0.01, 0.2).name('变形速度');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 运行手势检测
            detectHands();

            // 2. 更新粒子位置
            const positions = geometry.attributes.position.array;
            const targets = geometry.userData.target;

            controls.update();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 获取当前基础形状的目标位置
                const tx = targets[i3];
                const ty = targets[i3 + 1];
                const tz = targets[i3 + 2];

                // 应用手势缩放
                // 粒子最终目标 = 基础形状位置 * 手势缩放因子
                const targetX = tx * handScaleFactor * config.baseScale;
                const targetY = ty * handScaleFactor * config.baseScale;
                const targetZ = tz * handScaleFactor * config.baseScale;

                // 线性插值移动粒子 (Lerp)
                positions[i3] += (targetX - positions[i3]) * config.speed;
                positions[i3 + 1] += (targetY - positions[i3 + 1]) * config.speed;
                positions[i3 + 2] += (targetZ - positions[i3 + 2]) * config.speed;
            }

            geometry.attributes.position.needsUpdate = true;

            // 3. 渲染
            renderer.render(scene, camera);
        }

        // 启动
        init();
    </script>
</body>
</html>